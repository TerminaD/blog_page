<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>Stanford CS 106L (Standard C++ Programming) - An Outline · termina's Blog</title><meta name="description" content="IntroI C++1.  Why C++?
high performance
universally supported

2. Robust Backwards Compatibility
C and Assembly compatible
which also makes C++ very m"><meta name="og:description" content="IntroI C++1.  Why C++?
high performance
universally supported

2. Robust Backwards Compatibility
C and Assembly compatible
which also makes C++ very m"><meta name="twitter:site" content="termina's Blog"><meta name="twitter:title" content="Stanford CS 106L (Standard C++ Programming) - An Outline"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="container" id="stage"><div class="row"><div class="col-sm-3 col-xs-12 side-container invisible" id="side-bar"><div class="vertical-text site-title"><h3 class="site-title-small" tabindex="-1"><a class="a-title" href="/">Typography</a></h3><h1 class="site-title-large" tabindex="-1"><a class="a-title" href="/">活版印字</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div class="site-title-links" id="site-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li class="soc"><a href="https://www.termina.me/atom.xml" target="_blank" rel="noopener noreferrer" aria-label="RSS"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2023&nbsp;<a target="_blank" href="https://www.termina.me" rel="noopener noreferrer">termina</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div class="col-sm-9 col-xs-12 main-container invisible" id="main-container"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>Stanford CS 106L (Standard C++ Programming) - An Outline</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2022-05-03</span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a class="a-tag" href="/categories/笔记/" title="笔记">笔记</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a class="a-tag" href="/tags/CS/" title="CS">CS</a><span>&nbsp;</span><a class="a-tag" href="/tags/C/" title="C++">C++</a><span>&nbsp;</span></span></p><p class="post-abstract"><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><h2 id="I-C"><a href="#I-C" class="headerlink" title="I C++"></a>I C++</h2><h3 id="1-Why-C"><a href="#1-Why-C" class="headerlink" title="1.  Why C++?"></a>1.  Why C++?</h3><ul>
<li>high performance</li>
<li>universally supported</li>
</ul>
<h3 id="2-Robust-Backwards-Compatibility"><a href="#2-Robust-Backwards-Compatibility" class="headerlink" title="2. Robust Backwards Compatibility"></a>2. Robust Backwards Compatibility</h3><ul>
<li>C and Assembly compatible</li>
<li>which also makes C++ very messy to work with</li>
</ul>
<h3 id="3-Design-Philosophy"><a href="#3-Design-Philosophy" class="headerlink" title="3. Design Philosophy"></a>3. Design Philosophy</h3><ol>
<li>only add features if they solve an actual problem</li>
<li>full control if wanted (manual memory allocation)</li>
<li>express ideas and intent directly in code (<code>const</code>)</li>
<li>enforce safely at <strong>compile time</strong> whenever possible</li>
<li>do not waste time or space</li>
<li>compartmentalize messy constructs</li>
</ol>
<h2 id="II-This-Course"><a href="#II-This-Course" class="headerlink" title="II This Course"></a>II This Course</h2><h3 id="1-Goals"><a href="#1-Goals" class="headerlink" title="1. Goals"></a>1. Goals</h3><ol>
<li>what features exist out there and what are they meant for</li>
<li>get comfortable with reading documentation</li>
<li>understand C++’s design philosophy</li>
</ol>
<h3 id="2-Roadmap"><a href="#2-Roadmap" class="headerlink" title="2. Roadmap"></a>2. Roadmap</h3>


<h1 id="Fundamentals-of-C"><a href="#Fundamentals-of-C" class="headerlink" title="Fundamentals of C++"></a>Fundamentals of C++</h1><h2 id="I-Streams"><a href="#I-Streams" class="headerlink" title="I Streams"></a>I Streams</h2><h3 id="1-What-are-streams"><a href="#1-What-are-streams" class="headerlink" title="1. What are streams?"></a>1. What are streams?</h3><ul>
<li>a unified interface for <strong>connecting with other devices</strong>: consoles and keyboards, files, other programs, network sockets</li>
<li>automatically <strong>converts types</strong></li>
<li>store stuff into the buffer from the source, <strong>flushing</strong> it into the target</li>
</ul>
<h3 id="2-State-Bits"><a href="#2-State-Bits" class="headerlink" title="2. State Bits"></a>2. State Bits</h3><ol>
<li><strong>Good Bit:</strong> ready for read&#x2F;write.</li>
<li><strong>Fail Bit:</strong> operation failed and all future operations frozen. (type mismatch, file failed to open)</li>
<li><strong>EOF Bit:</strong> end of buffer reached.</li>
<li><strong>Bad Bit:</strong> external error, likely irrecoverable. (file suddenly deleted)</li>
</ol>
<ul>
<li><p>G and B are not opposites</p>
</li>
<li><p>G and F are not opposites</p>
</li>
<li><p><strong>usually check F and E, rarely check G</strong></p>
</li>
</ul>
<h3 id="3-Buffer"><a href="#3-Buffer" class="headerlink" title="3. Buffer"></a>3. Buffer</h3><ul>
<li>whenever stuff is output to <code>cout</code>, it stores them in a buffer and prints them out all at once when the buffer is flushed, to optimize performance</li>
<li><code>cerr</code> is unbuffered</li>
<li><code>endl</code> is an newline character plus a flush</li>
<li><code>cin</code> automatically flushes <code>cout</code></li>
</ul>
<h3 id="4-String-Streams"><a href="#4-String-Streams" class="headerlink" title="4. String Streams"></a>4. String Streams</h3><ul>
<li>connects to nothing</li>
<li>sole function being converting other types to and fro <code>string</code></li>
<li>has modes of operation: overwrite, append, etc.</li>
<li>useful for converting other types to and fro <code>string</code></li>
</ul>
<pre class="line-numbers language-C++"><code class="language-C++">istringstream iss; 

// input "16.9 ounces" 
cin >> iss; 

double amount; 
std::string unit;

iss >> amount; // Reads until a whitespace is encountered or what it reads no longer makes sense, whichever comes first 
iss >> unit;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++"><code class="language-C++">// Construction
// Each stream gets its own buffer
ostringstream oss("Whatever");

// dump the oss buffer into a string
std::cout << oss.str() << std::endl; // outputs "Whatever"

// put stuff into the oss buffer
oss << "When";
std::cout<<oss.str()<<std::endl; // outputs "Whenever". The stream is overwritten!
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="5-IO-Streams"><a href="#5-IO-Streams" class="headerlink" title="5. IO Streams"></a>5. IO Streams</h3><p><strong>How they work</strong></p>
<ol>
<li>First call to <code>std::cin &gt;&gt;</code> creates a command line prompt that allows the user to type until they hit enter</li>
<li>When <code>cin</code> is empty, the program freezes</li>
<li>when <code>enter</code> is pressed, <code>cin</code> transfers the typed line into the buffer, reading until a whitespace is reached, <strong>not consumed</strong></li>
<li>in the next <code>cin</code> operation, all leading whitespaces are skipped, moving on to the next token</li>
<li><code>cin</code> prompts the user for input again when the <code>EOF</code> bit is on</li>
<li>when one <code>cin</code> operation fails, all future <code>cin</code> operations fail</li>
</ol>
<p><strong><code>getline</code> consumes the delimiter!<br>When mixing <code>cin</code> with <code>getline</code>, do so with great discern!</strong></p>
<h3 id="6-The-Stream-Operator"><a href="#6-The-Stream-Operator" class="headerlink" title="6. The Stream Operator"></a>6. The Stream Operator</h3><ul>
<li>turn the rhs object into characters and insert them to the lhs buffer</li>
<li><strong>operator chaining:</strong> after each step, the operator chain collapses and the leftmost object is removed</li>
</ul>
<h3 id="7-String-Positioning-Functions"><a href="#7-String-Positioning-Functions" class="headerlink" title="7. String Positioning Functions"></a>7. String Positioning Functions</h3><p>consult Google when needed</p>
<h3 id="8-Manipulators"><a href="#8-Manipulators" class="headerlink" title="8. Manipulators"></a>8. Manipulators</h3><p>consult Google when needed</p>
<h3 id="9-Misc"><a href="#9-Misc" class="headerlink" title="9. Misc"></a>9. Misc</h3><ul>
<li>if operation fails, the cursor go back to the original position</li>
<li>EOF is only on when you read <strong>past</strong> the whitespace or EOF (important for file streams)<br>Thus, read from the <code>iss</code> one more char at the end.</li>
<li><code>iss &gt;&gt; result</code> returns a value, 1 for valid, 0 for invalid.</li>
</ul>
<h2 id="II-Initialization"><a href="#II-Initialization" class="headerlink" title="II Initialization"></a>II Initialization</h2><h3 id="1-auto"><a href="#1-auto" class="headerlink" title="1. auto"></a>1. <code>auto</code></h3><h3 id="2-Uniform-Initialization"><a href="#2-Uniform-Initialization" class="headerlink" title="2. Uniform Initialization"></a>2. Uniform Initialization</h3><p><code>type var&#123;arg1, arg2, ...arg_n&#125;</code></p>
<h3 id="3-Structured-Binding"><a href="#3-Structured-Binding" class="headerlink" title="3. Structured Binding"></a>3. Structured Binding</h3><ul>
<li><strong>captures variables</strong> from pairs and structs</li>
</ul>
<pre class="line-numbers language-C++"><code class="language-C++">auto p = std::make_pair(1, "Adam");

auto [no, name] = p;

std::cout << no << std::endl << name;
// 1
// Adam
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="III-const"><a href="#III-const" class="headerlink" title="III const"></a>III <code>const</code></h2><h3 id="1-The-4-Use-Cases"><a href="#1-The-4-Use-Cases" class="headerlink" title="1. The 4 Use Cases"></a>1. The 4 Use Cases</h3><ol>
<li>When declaring a variable: make the variable a constant</li>
<li>When prefixing it to a function’s return value: does it make much sense?</li>
<li>When prefixing it to a function’s arguments: make sure that the <strong>arguments</strong> passed in <strong>can’t be modified</strong>.<br> <strong>Note that a <code>const</code> argument can be both const and non-const; while a non-const argument can only be non-const.</strong></li>
<li>When postfixing it to a <strong>member</strong> function: make the function a constant interface, which means it <strong>can only call <code>const</code> functions and cannot change variables</strong></li>
</ol>
<h3 id="2-Const-Correctness"><a href="#2-Const-Correctness" class="headerlink" title="2. Const Correctness"></a>2. Const Correctness</h3><ul>
<li>whether to use <code>const</code> is crucial when <strong>passing by reference</strong></li>
<li><code>const_cast</code>: make a const variable non-const</li>
</ul>
<h3 id="3-Const-Pointers-and-Iterators"><a href="#3-Const-Pointers-and-Iterators" class="headerlink" title="3. Const Pointers and Iterators"></a>3. Const Pointers and Iterators</h3><ol>
<li>const pointer: read from right to left</li>
<li><code>const vector&lt;int&gt;::iterator</code> : the iterator can’t move, but the pointed-to element is writable</li>
<li><code>const_iterator</code>: the iterator is free to move but read-only</li>
</ol>
<h3 id="4-Misc"><a href="#4-Misc" class="headerlink" title="4. Misc"></a>4. Misc</h3><p>since a member function might be called on <code>const</code> and non-<code>const</code> variables alike, its suggested that one <strong>overload member functions as <code>const</code> and non-<code>const</code></strong> whenever possible</p>
<h2 id="IV-References"><a href="#IV-References" class="headerlink" title="IV References"></a>IV References</h2><h3 id="1-l-values-and-r-values"><a href="#1-l-values-and-r-values" class="headerlink" title="1. l-values and r-values"></a>1. l-values and r-values</h3><ul>
<li><p>a l-value has a name; a r-value does not</p>
</li>
<li><p>a l-value can be pointed to and referenced; a r-value cannot</p>
</li>
<li><p>a l-value can appear on the lhs and rhs; a r-value can only appear on the rhs</p>
</li>
<li><p>crucial when dealing with move semantics: <strong>you can only copy from l-values, but you can copy or move from r-values.</strong></p>
</li>
<li><p>further reading: x-values, gl-values, pr-values</p>
</li>
</ul>
<h3 id="2-Workings"><a href="#2-Workings" class="headerlink" title="2. Workings"></a>2. Workings</h3><ul>
<li>basically an alias of, or alternative access to, an already existing variable</li>
<li>useful when passing large variables to functions to reduce time and space overhead</li>
</ul>
<h3 id="3-r-value-References"><a href="#3-r-value-References" class="headerlink" title="3. r-value References"></a>3. r-value References</h3><ul>
<li><p>denoted with double ampersands (<code>auto&amp;&amp;</code>)</p>
</li>
<li><p>extends the lifetime of a temporary object</p>
</li>
<li><p>l-value reference binds to l-values</p>
</li>
<li><p>r-value reference binds to r-values</p>
</li>
<li><p><strong>const l-value reference binds to r-values!</strong></p>
</li>
</ul>
<h3 id="4-Perfect-Forwarding"><a href="#4-Perfect-Forwarding" class="headerlink" title="4. Perfect Forwarding"></a>4. Perfect Forwarding</h3><ol>
<li><p>What it does: <strong>pass the r&#x2F;l-ness of an outer template function to an inner function</strong> to reduce overhead.</p>
</li>
<li><p>Prior knowledge: template type deduction, reference collapsing</p>
</li>
<li><p><code>std::forward</code></p>
</li>
</ol>
<h1 id="The-Standard-Template-Library"><a href="#The-Standard-Template-Library" class="headerlink" title="The Standard Template Library"></a>The Standard Template Library</h1><h2 id="I-Containers"><a href="#I-Containers" class="headerlink" title="I Containers"></a>I Containers</h2><h3 id="1-Sequence-Containers"><a href="#1-Sequence-Containers" class="headerlink" title="1. Sequence Containers"></a>1. Sequence Containers</h3><ol>
<li><p><code>vector</code></p>
<ul>
<li>the de facto sequence container</li>
<li><strong>random access iterator</strong></li>
<li><strong>insertion and deletion at back</strong></li>
</ul>
</li>
<li><p><code>deque</code></p>
<ul>
<li>used when modification at front is required</li>
<li><strong>random access iterator</strong></li>
<li><strong>insertion and deletion at both ends</strong></li>
<li>slightly slower than <code>vector</code></li>
</ul>
</li>
<li><p><code>list</code></p>
<ul>
<li><strong>two-way iterator</strong></li>
<li><strong>insertion and deletion anywhere</strong></li>
</ul>
</li>
<li><p><code>forward_list</code></p>
<ul>
<li>a wrapper for singly linked list</li>
<li><strong>forward iterator</strong></li>
<li><strong>insertion and deletion anywhere</strong></li>
</ul>
</li>
<li><p><code>array</code></p>
<ul>
<li>basically a C-styled array</li>
<li>why would anyone want to use that?</li>
</ul>
</li>
</ol>
<p><code>emplace_back</code>: Takes in arguments needed to initialize the element and create it on spot. <strong>Less copying!</strong></p>
<h3 id="2-Associative-Containers"><a href="#2-Associative-Containers" class="headerlink" title="2. Associative Containers"></a>2. Associative Containers</h3><ol>
<li><p><code>map</code></p>
<ul>
<li>implemented with BST</li>
<li>only prefer this to <code>unordered_map</code> when sequential traversal is needed</li>
</ul>
</li>
<li><p><code>unordered_map</code></p>
<ul>
<li>implemented with hash functions</li>
<li>especially preferred when working with large data sets</li>
</ul>
</li>
<li><p><code>multimap</code></p>
<ul>
<li>does not have the <code>[]</code> operator</li>
<li>add element by <code>.insert(make_pair(a, b))</code></li>
</ul>
</li>
<li><p><code>unordered_multimap</code></p>
</li>
<li><p><code>set</code></p>
</li>
<li><p><code>unordered_set</code></p>
</li>
<li><p><code>multiset</code></p>
</li>
<li><p><code>unordered_multiset</code></p>
</li>
</ol>
<h3 id="3-Container-Adapters"><a href="#3-Container-Adapters" class="headerlink" title="3. Container Adapters"></a>3. Container Adapters</h3><ol>
<li><p><code>stack</code></p>
<ul>
<li>built upon <code>vector</code></li>
<li>only interfaces related to the stack data structure are exposed, explicitly expressing intent</li>
<li>yet can be specified to be built upon other containers</li>
</ul>
</li>
<li><p><code>queue</code></p>
<ul>
<li>similar to above, but build on <code>deque</code></li>
</ul>
</li>
<li><p><code>priority_queue</code></p>
<ul>
<li>built upon <code>vector</code></li>
<li>automatically puts the greatest priority (max by default) element at the top</li>
<li>max priority element access: $O(1)$</li>
<li><strong>insertion and popping the top element</strong></li>
</ul>
</li>
</ol>
<h3 id="4-Iterators"><a href="#4-Iterators" class="headerlink" title="4. Iterators"></a>4. Iterators</h3><ul>
<li>provides a <strong>universal interface</strong> for all containers</li>
<li>forward iterators, reverse iterators, constant iterators</li>
<li><strong>Iterator Adapters</strong><ul>
<li><code>back_inserter</code></li>
<li>stream iterator</li>
</ul>
</li>
</ul>
<h4 id="Iterator-Types"><a href="#Iterator-Types" class="headerlink" title="Iterator Types"></a>Iterator Types</h4>
<ol>
<li><p>They can all be:</p>
<ul>
<li>created from existing iterators</li>
<li>incremented</li>
<li>compared with <code>==</code> and <code>!=</code></li>
</ul>
</li>
<li><p>Input Iterators</p>
<ul>
<li>sequential and <strong>single-pass</strong></li>
<li>read only</li>
<li>used for inputing stuff into functions and streams</li>
<li>e.g. <code>find</code>, <code>count</code>, input streams</li>
</ul>
</li>
<li><p>Output Iterators</p>
<ul>
<li>sequential and <strong>single-pass</strong></li>
<li>write only</li>
<li>used for writing data into where the iterator is pointing</li>
<li>e.g. <code>copy</code>, output streams</li>
</ul>
</li>
<li><p>Forward Iterators</p>
<ul>
<li>sequential and multi-pass</li>
<li>read and write</li>
</ul>
</li>
<li><p>Bidirectional Iterators</p>
<ul>
<li>bidirectionally sequential and multi-pass</li>
<li>read and write</li>
</ul>
</li>
<li><p>Random Access Iterators</p>
<ul>
<li>can perform arithmetic operations on them, e.g. <code>itr += 3</code> or <code>itr1 -= (2 * itr2)</code></li>
<li>multi-pass</li>
<li>read and write</li>
</ul>
</li>
</ol>
<h2 id="II-Algorithms"><a href="#II-Algorithms" class="headerlink" title="II Algorithms"></a>II Algorithms</h2><p><code>count</code>, <code>count_if</code>, <code>sort</code>, <code>nth_element</code>, <code>stable_partition</code>, <code>copy_if</code>, <code>remove_if</code>, <code>search</code>, <code>find</code></p>
<ul>
<li>Notice that for <code>copy_if</code>, you need to use <strong><code>back_inserter</code></strong> for the target iterator argument, since it allows for the container to dynamically resize.</li>
<li><code>remove</code> does not actually remove elements, just place them toward the end of the container, making necessary <strong>the erase-remove idiom:</strong><br>  <code>v.erase(std::remove(v.begin(), v.end(), predicate), v.end());</code></li>
</ul>
<h2 id="III-Misc"><a href="#III-Misc" class="headerlink" title="III Misc"></a>III Misc</h2><ol>
<li>The regex library</li>
<li>The Boost library</li>
</ol>
<h1 id="Object-Oriented-Programming"><a href="#Object-Oriented-Programming" class="headerlink" title="Object-Oriented Programming"></a>Object-Oriented Programming</h1><h2 id="I-Function-Templates"><a href="#I-Function-Templates" class="headerlink" title="I Function Templates"></a>I Function Templates</h2><ol>
<li><p>expanded (like macros) at <strong>compile time</strong>, thus making it a form of compile time polymorphism</p>
</li>
<li><p>template key words:</p>
<ul>
<li><code>typename</code>&#x2F;<code>class</code><br>  can be used to pass in basic types, structs, classes, and <strong>predicates</strong>(kinda like functions)</li>
<li><code>size_t</code></li>
</ul>
</li>
<li><p>Concepts Lifting</p>
<ul>
<li>a thought process for making a function more universal</li>
<li>peel away restraining assumptions in your code</li>
</ul>
</li>
<li><p>Implicit Interface</p>
<ul>
<li>every template function comes with <strong>implicit restraints</strong> about the type passed in embedded in the code</li>
</ul>
</li>
<li><p>Further reading<br> Concepts and Constraints (C++20)</p>
</li>
</ol>
<h2 id="II-Classes-Overview"><a href="#II-Classes-Overview" class="headerlink" title="II Classes Overview"></a>II Classes Overview</h2><ol>
<li>.h files and .cpp files<br> .h files include the interface<br> .cpp files include the dirty implementation details</li>
</ol>
<h2 id="III-Namespaces"><a href="#III-Namespaces" class="headerlink" title="III Namespaces"></a>III Namespaces</h2><pre class="line-numbers language-C++"><code class="language-C++">namespace name
&#123;
    function_definition&#123;...&#125;;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="IV-Operators"><a href="#IV-Operators" class="headerlink" title="IV Operators"></a>IV Operators</h2>

<ol>
<li><p><strong>Pay close attention to <code>const</code> and reference!</strong></p>
</li>
<li><p>Implement as member function or non-member function?</p>
<ol>
<li>Some (e.g. <code>[]</code>, <code>()</code>, <code>-&gt;</code>, <code>=</code>) must be member.	</li>
<li>Some (e.g. <code>&lt;&lt;</code>), where you are writing class for rhs, must be non-member. Using friends might be needed.</li>
<li>Implement unary operators as member.</li>
<li>If symmetrical, implement as non-member. This is to prevent calling member operators on r-values.</li>
<li>If non-symmetrical, implement as member.</li>
</ol>
</li>
<li><p>Principle of Least Astonishment (POLA)</p>
</li>
<li><p>Always provide a set of operators.</p>
</li>
<li><p>To work with both const and non-const objects, certain operators (e.g. <code>[]</code>) might need to be <strong>overloaded as both const and non-const.</strong></p>
</li>
<li><p>Misc:</p>
<ol start="6">
<li>Overload <code>-&gt;</code> for smart pointers</li>
<li>allocator operator</li>
<li>spaceship operator <code>&lt;=&gt;</code></li>
</ol>
</li>
</ol>
<h2 id="V-Special-Member-Functions"><a href="#V-Special-Member-Functions" class="headerlink" title="V Special Member Functions"></a>V Special Member Functions</h2><h3 id="1-Constructor"><a href="#1-Constructor" class="headerlink" title="1. Constructor"></a>1. Constructor</h3><ul>
<li>use <strong>member initializer list</strong> to initialize <strong>const member variables</strong> and <strong>references</strong></li>
<li><strong>C++’s most vexing parse:</strong></li>
</ul>
<pre class="line-numbers language-C++"><code class="language-C++">className classInstance1; // Calls the constructor
className classInstance2(); // Compile error!
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="2-Destructor"><a href="#2-Destructor" class="headerlink" title="2. Destructor"></a>2. Destructor</h3><h3 id="3-Copy-Constructor"><a href="#3-Copy-Constructor" class="headerlink" title="3. Copy Constructor"></a>3. Copy Constructor</h3><ul>
<li><p>called when creating a new object out of an existing object</p>
</li>
<li><p>Should do:</p>
<ol>
<li>Use initializer list to copy members when it works.</li>
<li>For references and pointers, perform a deep copy. <strong>Beware of multi-free scenarios!</strong></li>
</ol>
</li>
<li><p>copy elision and return value optimization (RVO)</p>
</li>
</ul>
<h3 id="4-Copy-Assignment"><a href="#4-Copy-Assignment" class="headerlink" title="4. Copy Assignment"></a>4. Copy Assignment</h3><ul>
<li><p>called when lhs and rhs both already exist</p>
</li>
<li><p>Should do:</p>
<ol>
<li>Make sure it’s <strong>not self-assignment</strong>!</li>
<li><strong>Free lhs’s resources.</strong></li>
<li>Use initializer list to copy members when it works.</li>
<li>For references and pointers, perform a deep copy.</li>
</ol>
</li>
</ul>
<h3 id="5-Move-Constructor"><a href="#5-Move-Constructor" class="headerlink" title="5. Move Constructor"></a>5. Move Constructor</h3><ul>
<li><p><strong>Move Semantics:</strong> prefer moving other objects’ property to creating a copy, thus reducing space and time overhead</p>
</li>
<li><p>creating a new object by <strong>“stealing” the resources</strong> from a r-value on rhs</p>
</li>
<li><p>Should do:</p>
<ol>
<li>Use initializer list and <code>std::move()</code> to initialize all that can be initialized.</li>
<li>Change ownership of pointers and references.</li>
<li>Release rhs’s resources.</li>
</ol>
</li>
<li><p>Even if rhs is passed in as a r-value reference, within the scope of the move constructor, rhs is treated as a l-value, making necessary the use of <code>std::move()</code>, which casts l-values into r-values. <strong>Only do so on short-lived objects!</strong></p>
</li>
</ul>
<h3 id="6-Move-Assignment"><a href="#6-Move-Assignment" class="headerlink" title="6. Move Assignment"></a>6. Move Assignment</h3><ul>
<li>Should do:<ol>
<li>Make sure it’s not self-assignment.</li>
<li>Free lhs’s resources.</li>
<li>Use initializer list and <code>std::move()</code> to initialize all that can be initialized.</li>
<li>Change ownership of pointers and references.</li>
<li>Release rhs’s resources.</li>
</ol>
</li>
</ul>
<h3 id="7-Rule-of-Five"><a href="#7-Rule-of-Five" class="headerlink" title="7. Rule of Five"></a>7. Rule of Five</h3><ul>
<li>When your class has ownership issues (e.g. pointers, references, mutexes, file streams), you might want to implement your own special member functions.</li>
<li>For copy construction, copy assignment, move construction, move assignment, destruction, if you explicitly implement or delete one of them, you should also do so to all of them.</li>
</ul>
<h3 id="8-RAII-Resource-Acquisition-is-Initialization"><a href="#8-RAII-Resource-Acquisition-is-Initialization" class="headerlink" title="8. RAII (Resource Acquisition is Initialization)"></a>8. RAII (Resource Acquisition is Initialization)</h3><ul>
<li><p>or more aptly, <strong>CADRE</strong> (Constructor Acquires, Destructor Releases)</p>
</li>
<li><p>If an exception is thrown while an object is in scope, then the resources it acquired are never properly releases, causing a memory leak.</p>
</li>
<li><p>This is also why we use <code>noexcept</code> when writing special member functions.</p>
</li>
<li><p>e.g.</p>
</li>
</ul>
<pre class="line-numbers language-C++"><code class="language-C++">// Use this:
ifstream input("hamlet.txt");

// Instead of this:
ifstream input();
input.open("hamlet.txt");

// BTW, ifstreams automatically calls its own destructor when it goes out of scope, releasing all its resources. Ain't that sweet?
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++"><code class="language-C++">// Use this:
lock_guard<mutex>(databaseLock);
// lock_guard is basically a wrapper to make mutex locks RAII complaint.

// Instead of this:
databaseLock.lock();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="VI-Inheritance"><a href="#VI-Inheritance" class="headerlink" title="VI Inheritance"></a>VI Inheritance</h2><h3 id="1-How-inheritance-works"><a href="#1-How-inheritance-works" class="headerlink" title="1. How inheritance works"></a>1. How inheritance works</h3><ul>
<li>the derived class inherits the member variables (it doesn’t inherit their value) and the member functions (with their implementation) from the base class.</li>
<li>If two member variables are defined in the base class and the derived class, the derived version overrides the base one.</li>
</ul>
<h3 id="2-Access-Modes"><a href="#2-Access-Modes" class="headerlink" title="2. Access Modes"></a>2. Access Modes</h3><p><code>public</code>, <code>protected</code>, <code>private</code></p>
<h3 id="3-Overriding-base-member-functions-Virtual-Functions"><a href="#3-Overriding-base-member-functions-Virtual-Functions" class="headerlink" title="3. Overriding base member functions: Virtual Functions"></a>3. Overriding base member functions: <strong>Virtual Functions</strong></h3><ul>
<li><p>only virtual functions can be overridden by functions of a derived class	</p>
</li>
<li><p><code>= 0</code> makes it a pure virtual function</p>
</li>
<li><p>Classes with pure virtual functions are called <strong>abstract classes</strong>. Abstract classes cannot be instantiated.</p>
</li>
<li><p>Classes with only pure virtual functions are called <strong>interfaces</strong>.</p>
</li>
</ul>
<h3 id="4-Inheritance-and-Special-Member-Functions"><a href="#4-Inheritance-and-Special-Member-Functions" class="headerlink" title="4. Inheritance and Special Member Functions"></a>4. Inheritance and Special Member Functions</h3><ul>
<li>When defining the constructor of a derived class, call the constructor for the base class. The same goes for destructors.</li>
</ul>
<pre class="line-numbers language-C++"><code class="language-C++">Derived() : Base(args)&#123;...&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>If a class is meant to be inheritable, <strong>make the destructor virtual</strong>.</li>
</ul>
<h3 id="5-Inheritance-and-Pointers"><a href="#5-Inheritance-and-Pointers" class="headerlink" title="5. Inheritance and Pointers"></a>5. Inheritance and Pointers</h3><ul>
<li>a pointer to a derived class is type-compatible with a pointer to its base class, thus making possible: <code>Base* ptr = new Derived()</code></li>
<li>this can be used to access member variables and functions of the derived class that are inherited from the base class</li>
<li>super confusing and prone to memory leaks… not sure why would you want to use it</li>
</ul>
<h3 id="6-Inheritance-vs-Templates"><a href="#6-Inheritance-vs-Templates" class="headerlink" title="6. Inheritance vs. Templates"></a>6. Inheritance vs. Templates</h3><ul>
<li><p>Inheritance is dynamic and explicit</p>
</li>
<li><p>Template is static and implicit</p>
</li>
<li><p>use inheritance when:</p>
<ul>
<li>compile time efficiency is important</li>
<li>keep the compiled code trim</li>
</ul>
</li>
<li><p>use templates when:</p>
<ul>
<li>runtime efficiency is important</li>
<li>no common code base</li>
</ul>
</li>
</ul>
<h3 id="7-Further-Reading"><a href="#7-Further-Reading" class="headerlink" title="7. Further Reading"></a>7. Further Reading</h3><ol>
<li>the inner workings</li>
<li>how pointers and references interact with inheritance</li>
</ol>
<h2 id="VII-Class-Templates"><a href="#VII-Class-Templates" class="headerlink" title="VII Class Templates"></a>VII Class Templates</h2><ul>
<li>put the interface and implementation all in the <strong>header file</strong></li>
</ul>
<h1 id="Modern-C"><a href="#Modern-C" class="headerlink" title="Modern C++"></a>Modern C++</h1><h2 id="I-Lambdas"><a href="#I-Lambdas" class="headerlink" title="I Lambdas"></a>I Lambdas</h2><ol>
<li><p>Why do you need lambdas?<br> To use data <strong>not available at compile time</strong>.</p>
</li>
<li><p>Syntax</p>
</li>
</ol>
<pre class="line-numbers language-C++"><code class="language-C++">auto func = [capture_clause] (parameters) -> return_value
&#123;
    body;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>Where <code>capture_clause</code> is a list of the variables to be captured.</p>
</li>
<li><p>You can also capture by reference.</p>
</li>
<li><p><code>=</code> means capturing everything in scope by value unless stating capturing another variable by reference. The same goes for <code>&amp;</code>.</p>
</li>
<li><p><code>-&gt; return_value</code> is optional.</p>
</li>
<li><p>underlining workings: create a class</p>
</li>
<li><p>Thus the <code>;</code></p>
</li>
</ul>
<h2 id="II-Smart-Pointers"><a href="#II-Smart-Pointers" class="headerlink" title="II Smart Pointers"></a>II Smart Pointers</h2><ul>
<li>an RAII-complaint wrapper for raw pointers</li>
</ul>
<h3 id="Three-Flavors"><a href="#Three-Flavors" class="headerlink" title="Three Flavors:"></a>Three Flavors:</h3><ol>
<li><p><code>unique_ptr</code></p>
<ul>
<li>only one <code>unique_ptr</code> for a certain object is allowed</li>
<li>can’t be copied (the copy construction and copy assignment are deleted)</li>
</ul>
</li>
<li><p><code>shared_ptr</code></p>
<ul>
<li>multiple <code>shared_ptr</code> to the same object is allowed</li>
<li>released when the all of them are out of scope</li>
<li>implemented using a reference count</li>
<li><strong>copy rather than reference</strong></li>
</ul>
</li>
<li><p><code>weak_ptr</code></p>
<ul>
<li>similar to a <code>shared_ptr</code>, but doesn’t contribute to the reference count</li>
<li><strong>used for circular references</strong></li>
<li>consult documentation for more</li>
</ul>
</li>
</ol>
<h3 id="Creating-Smart-Pointers"><a href="#Creating-Smart-Pointers" class="headerlink" title="Creating Smart Pointers"></a>Creating Smart Pointers</h3><p>use <code>make_unique</code> and <code>make_shared</code></p>
<h2 id="III-Multithreading"><a href="#III-Multithreading" class="headerlink" title="III Multithreading"></a>III Multithreading</h2><ul>
<li><p>multithreading vs. multiprocessing</p>
</li>
<li><p>make the program run <strong>in parallel</strong> instead of sequentially</p>
</li>
</ul>
<h3 id="Libraries-Used"><a href="#Libraries-Used" class="headerlink" title="Libraries Used:"></a>Libraries Used:</h3><ol>
<li><p><code>&lt;atomic&gt;</code><br> makes variables and operations atomic (that is to say, completed in one step instead of many)</p>
</li>
<li><p><code>&lt;thread&gt;</code><br> manages threads’ branching and merging<br> <strong>must use references on threads!</strong></p>
</li>
<li><p><code>&lt;mutex&gt;</code><br> limits access to a certain variable</p>
</li>
<li><p><code>&lt;condition_variable&gt;</code></p>
</li>
<li><p><code>&lt;future&gt;</code></p>
</li>
</ol>
<h3 id="Crash-Course-on-Writing-Multithreaded-Programs"><a href="#Crash-Course-on-Writing-Multithreaded-Programs" class="headerlink" title="Crash Course on Writing Multithreaded Programs"></a>Crash Course on Writing Multithreaded Programs</h3><ol>
<li>use <code>thread</code> to create a new thread</li>
<li>use <code>lock_guard</code> and <code>mutex</code> to prevent other threads from accessing resources when one thread is running</li>
<li>use <code>.join</code> to control in what order the threads finish running</li>
</ol>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></span><span class="soc"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></span><span class="soc"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=https://www.termina.me/笔记/cs106l_notes/%20termina's Blog%20Stanford CS 106L (Standard C++ Programming) - An Outline"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/%E5%86%99%E4%BD%9C/mr_morale_and_the_big_steppers/" title="Mr. Morale &amp; The Big Steppers - A Review"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: Mr. Morale & The Big Steppers - A Review</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/%E5%86%99%E4%BD%9C/sakura_and_endings/" title="樱花、《花束》、终结">Next post: 樱花、《花束》、终结&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2023&nbsp;<a target="_blank" href="https://www.termina.me" rel="noopener noreferrer">termina</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>